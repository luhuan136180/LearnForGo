package controller

import (
	"Forumv1/logic"
	"Forumv1/models"
	"fmt"
	"github.com/gin-gonic/gin"
	"go.uber.org/zap"
)

func CreatePostHandler(c *gin.Context) {
	//获取参数和参数的校验
	post := new(models.Post) //创建
	//必填内容为：title，content和topicID
	if err := c.ShouldBindJSON(post); err != nil {
		zap.L().Debug("**c.shouldBindJson(p) error", zap.Any("err", err))
		zap.L().Error("***create post with invalid param", zap.Error(err))
		ResponseError(c, CodeInvalidParam)
		return
	}
	//从上下文中获取发帖人ID----请求的携带l请求发起人的id，而这个人就是作者
	userID, err := GetCurrentUser(c)
	if err != nil {
		ResponseError(c, CodeNeedLogin)
		return
	}
	//发起创建帖子请求的就是作者
	post.AuthorID = userID

	//创建帖子的业务流程
	if err := logic.CreatePost(post); err != nil {
		zap.L().Error("logic.CreatPost(p) failed", zap.Error(err))
		ResponseError(c, CodeServerBusy)
		return
	}
	//响应
	ResponseSuccess(c, nil)
}

//从前端获取key，然后在数据库中找到对应key
func GetPostByKeyHandler(c *gin.Context) {
	key := c.Param("key")
	fmt.Println(key)
	//
	data, err := logic.GetPostByKey(key)
	if err != nil {
		zap.L().Error("logic.GetPostByKey() failed", zap.Error(err))
		ResponseError(c, CodeServerBusy) // 不轻易把服务端报错暴露给外面
		return
	}
	ResponseSuccess(c, data)
	//ResponseSuccess(c, "success")
}

func GetPostsByTopicIDHandler(c *gin.Context) {
	//
	topicid := c.Param("topicid")
	//fmt.Println("topicID=", topicid)
	//获取一页显示的个数和页数
	page, size := GetpageInfo(c)
	//fmt.Println("page=", page, "  size=", size)
	//
	data, err := logic.GetPostsByTopicID(page, size, topicid)
	if err != nil {
		zap.L().Error("logic.GetPostsByTopicID() failed", zap.Error(err))
		ResponseError(c, CodeServerBusy)
		return
	}
	ResponseSuccess(c, data)
}

//对帖子的内容进行模糊查询---全部
func GetPostByContentLIKEHandler(c *gin.Context) {
	word := c.Param("word")
	//不需要分页版本，直接进入业务流程
	data, err := logic.GetPostByContentLIKE(word)
	if err != nil {
		zap.L().Error("logic.GetPostByContentLIKE() failed", zap.Error(err))
		ResponseError(c, CodeServerBusy)
		return
	}
	ResponseSuccess(c, data)

}

//回复没有标题，没有自己的post_id ，回复信息的post_id 等于主贴的post_id，
func CreateResponseHandler(c *gin.Context) {
	//获取数据————需要回复的帖子的主贴ID
	postkey := c.Param("postkey")
	//根据postkey找到对应的主贴信息，
	post, err := logic.GetPostByKey(postkey)
	if err != nil {
		zap.L().Error("logic.GetPostByKey() failed", zap.Error(err))
		ResponseError(c, CodeServerBusy) // 不轻易把服务端报错暴露给外面
		return
	}
	response := new(models.ResponseCreate)
	if err := c.ShouldBindJSON(response); err != nil { //传入content和topicID
		zap.L().Debug("**c.shouldBindJson(p) error", zap.Any("err", err))
		zap.L().Error("***create reponse with invalid param", zap.Error(err))
		ResponseError(c, CodeInvalidParam)
		return
	}
	response.ID = post.ID
	//将回复信息的post_id找到，然后创建一个回复结构体，有post_id,content,postkey,author_id   ————————先这样
	//从上下文中获取发帖人ID----请求的携带l请求发起人的id，而这个人就是作者
	userID, err := GetCurrentUser(c)
	if err != nil {
		ResponseError(c, CodeNeedLogin)
		return
	}
	response.AuthorID = userID
	if err := logic.CreatePostResponse(response); err != nil {
		zap.L().Error("logic.CreatePostResponse(p) failed", zap.Error(err))
		ResponseError(c, CodeServerBusy)
		return
	}
	ResponseSuccess(c, nil)
}

func GetAllPostsByPostKeyHandler(c *gin.Context) {
	c.JSON(200, gin.H{"data": "hahahaha"})
	////从前端读取一个postkey 切片
	//postKeyList := new(models.AutoGenerated)
	////根据切片中的postkey分别获取各个post，组合传递给前端
	//if err := c.ShouldBindJSON(postKeyList); err != nil {
	//	zap.L().Debug("**c.shouldBindJson(p) error", zap.Any("err", err))
	//	zap.L().Error("***create reponse with invalid param", zap.Error(err))
	//	ResponseError(c, CodeInvalidParam)
	//	return
	//}
	////绑定成功
	////fmt.Println(postKeyList)
	////进入业务流程
	//data, err := logic.GetAllPostsByPostKey(postKeyList)
	//if err != nil {
	//	zap.L().Error("logic.GetAllPostsByPostKey() failed", zap.Error(err))
	//	ResponseError(c, CodeServerBusy)
	//	return
	//}
	////响应
	//ResponseSuccess(c, data)
}
